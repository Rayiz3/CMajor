---
title: '[CM301] 05. 탐색 & 선택 (Searching & Selection)'
description: ''
author: Doun
date: 2025-10-19 14:00:00 +0900
categories: [CM301. 알고리즘]
tags: [알고리즘]
pin: true
math: true
mermaid: true
image:
  path: /assets/img/thumbnails/cm301/5.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
  alt: '[CM301] 05. 탐색 & 선택 (Searching & Selection)'
---
 &ensp;이번에는 정렬과 함께 자주 사용되는 작업인 **요소를 찾는** 문제에 대해 다뤄봅시다. 이는 요소를 찾는 방법에 따라 크기 **탐색** 문제와 **선택** 문제로 나눌 수 있습니다.

> 작성된 모든 코드는 Python의 형식을 빌린 유사 코드이며, 문법을 다소 무시한 부분이 있기 때문에 실행이 되지 않습니다.
{: .prompt-tip }

## 탐색 (Searching)

 &ensp;**탐색(Searching)** 문제는 주어진 배열에서 특정 값 $a$를 가지는 요소를 찾아 그 위치를 반환하는 것이 목표입니다. 몇 가지 대표적인 탐색 알고리즘과 그 복잡도에 대해 다뤄보겠습니다.

### 선형탐색 (Linear search)

```python
def linear_search(x[1, ..., n], a):
  i = 1
  while i <= n and x != a:  # 순회가 끝나거나 a를 찾을 때 까지
    i += 1  # 순회
  
  if i <= n:  # 만약 순회가 끝나기 전에 찾았으면
    result = i  # 그 때의 인덱스 반환
  else:  # 순회가 끝나 멈췄으면
    result = 0  # 찾지 못했으므로 0 반환

  return result
```

 &ensp;선형탐색은 처음부터 끝까지 순회하며 일치하는 값을 찾는 제일 단순한 방법입니다. 모든 요소를 하나씩 비교하기 때문에 탐색이 가능합니다.

<img src="{{ 'assets/img/illustration/cm301/5_1.png' | absolute_url }}" alt="image1" class="post" />

 &ensp;최악의 경우는 찾는 요소가 배열 맨 끝에 있을 때입니다. 이 경우 순회를 끝까지 진행하므로, 시간 복잡도는 $O(n)$입니다. 추가 메모리를 쓰지 않기에 공간 복잡도는 $O(1)$입니다.

### 이진탐색 (Binary search)

```python
def binary_search(x[1, ..., n], a):
  i = 1  # 처음
  j = n  # 끝

  while i < j:  # i와 j나 만날 때 까지
    m = floor((i + j) / 2)  # i와 j의 중간 (내림연산)
    
    if a > x[m]:  # a가 중간값보다 크면
      i = m + 1  # 중간 ~ 끝 구간에서 반복
    else:  # a가 중간값보다 작거나 같으면
      j = m  # 처음 ~ 중간 구간에서 반복
  
  if a = x[i]:  # a를 찾았으면
    result = i  # 그 때의 인덱스 반환
  else:  # 순회가 끝나 멈췄으면
    result = 0  # 찾지 못했으므로 0 반환
  
  return result
```

 &ensp;이진탐색은 찾는 값은 배열의 중간값과 비교하며 탐색 구간을 줄이는 방법입니다. 이를 위해서 배열은 **반드시 오름차순으로 정렬**되어 있어야 합니다. 정렬되었을 경우 a보다 크거나 작은 구간을 배제하여 요소가 존재하는 구간만을 선택하기 때문에 탐색이 가능합니다.

<img src="{{ 'assets/img/illustration/cm301/5_2.png' | absolute_url }}" alt="image2" class="post" />

 &ensp;배열의 상태나 요소의 위치와 관계 없이 i와 j가 만날 때까지 반복되기 때문에 특별히 **최악의 경우나 최선의 경우가 없습니다**. 시간 복잡도는 $O(\log{n})$이 되고, 추가 메모리를 쓰지 않기에 공간 복잡도는 $O(1)$입니다.

## 선택 (Selection)